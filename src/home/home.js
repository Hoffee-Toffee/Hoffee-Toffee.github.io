// Your web app's Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyBr-FeYR-6PIlK5JXVs5K50C9mtTpp-DEo",
  authDomain: "datacord-db.firebaseapp.com",
  projectId: "datacord-db",
  storageBucket: "datacord-db.appspot.com",
  messagingSenderId: "590361883150",
  appId: "1:590361883150:web:cf62a24d59b3b71173825f",
  measurementId: "G-X5FM6KYXKM"
};

// Initialize Firebase
firebase.initializeApp(firebaseConfig)

const db = firebase.firestore()
const auth = firebase.auth()

db.collection('data')
  .doc('sneezeData')
  .onSnapshot(async () => {
    const doc = await db.collection('data').doc('sneezeData').get()
    const sneezeData = JSON.parse(doc.data().data)

    let start = false

    if (window['sneezeData'] == undefined) start = true

    window['sneezeData'] = sneezeData

    if (start) setInterval(sneezeCalc, 800)
  })

function sneezeCalc() {
  const { count, updated } = window['sneezeData']

  // count
  set('count', count.toLocaleString())

  // started
  const started = new Date('December 31, 2022 11:59 PM GMT+1300 (New Zealand Daylight Time')
  set('start', started.toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: 'numeric',
    minute: 'numeric',
    hour12: true,
  }))

  // updated
  const updatedDate = new Date(updated);
  set('updated', updatedDate.toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: 'numeric',
    minute: 'numeric',
    hour12: true,
  }))

  // Ms since count start
  const msAgo = new Date() - started

  // daily
  // Divide count by difference in ms of current and start, (ms / (1000*60*60*24)) to get as days
  const daily = count / (msAgo / (1000 * 60 * 60 * 24))
  set('daily', daily.toLocaleString())

  // interval
  const intervalRaw = msAgo / count
  const interval = formatRelativeDate(intervalRaw, 0)
  set('interval', interval)

  // thousand
  const thousandMS = nextMilestone(1, count)
  set('thousandMS', thousandMS.toLocaleString())

  const thousand = thousandMS / (count / msAgo) - msAgo + updatedDate.getTime()
  set('thousand', formatRelativeDate(thousand, updatedDate))

  // tenThousand
  const tenThousandMS = nextMilestone(2, count)
  set("tenThousandMS", tenThousandMS.toLocaleString())

  const tenThousand = tenThousandMS / (count / msAgo) - msAgo + updatedDate.getTime()
  set('tenThousand', formatRelativeDate(tenThousand, updatedDate))

  // hunThousand
  const hunThousandMS = nextMilestone(3, count)
  set("hunThousandMS", hunThousandMS.toLocaleString())

  const hunThousand = hunThousandMS / (count / msAgo) - msAgo + updatedDate.getTime()
  set('hunThousand', formatRelativeDate(hunThousand, updatedDate))
}

function set(id, value) {
  document.getElementById(id).innerText = value
}

function formatRelativeDate(estimate, start) {
  let currentDate = (start !== undefined) ? new Date(start) : new Date()
  let estimateDate = new Date(estimate);
  let timeDiff = estimateDate - currentDate;

  let seconds = Math.floor(timeDiff / 1000);
  let minutes = Math.floor(seconds / 60);
  let hours = Math.floor(minutes / 60);
  let days = Math.floor(hours / 24);
  let years = Math.floor(days / 365);

  if (years >= 10) { // Just show the estimated year if a decade or so in the future
    return estimateDate.getFullYear().toString();
  } else if (years >= 2) { // Just show the estimated month and year if a couple of years or so in the future
    return estimateDate.toLocaleDateString('en-US', { year: 'numeric', month: 'long' });
  }
  else if (days >= 7) { // Just show the month and day if a week or so in the future (plus the year to avoid confusion)
    return estimateDate.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
  } else if (hours >= 1) { // Just show the hours and minutes remaining if an hour or so in the future
    minutes %= 60
    return `${hours} ${hours === 1 ? 'hour' : 'hours'}${minutes > 0 ? ` and ${minutes} ${minutes === 1 ? 'minute' : 'minutes'}` : ''}`;
  } else if (minutes >= 1) { // Just show the minutes and seconds remaining if a minute or so in the future
    seconds %= 60;
    return `${minutes} ${minutes === 1 ? 'minute' : 'minutes'}${seconds > 0 ? ` and ${seconds} ${seconds === 1 ? 'second' : 'seconds'}` : ''}`;
  } else { // Finally, all remaining estimates must be seconds away (negatives will go here, but none should be generated by this program)
    return `${seconds} ${seconds === 1 ? 'second' : 'seconds'}`;
  }
}

function nextMilestone(level, count) {
  let milestone = 100 * Math.pow(10, level)
  let round = Math.ceil(count / milestone) * milestone

  return round == count ? count + milestone : round
}